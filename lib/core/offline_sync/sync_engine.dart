import 'dart:convert';
import 'dart:math';
import 'package:dio/dio.dart';
import 'package:drift/drift.dart';
import '../network/dio_client.dart';
import '../storage/database/app_database.dart';
import '../storage/database/tables/sync_queue_table.dart';
import '../utils/logger.dart';
import '../utils/connectivity.dart';
import 'sync_queue_repository.dart';

class SyncEngine {
  final DioClient _dioClient;
  final SyncQueueRepository _syncQueueRepository;
  bool _isSyncing = false;

  SyncEngine(this._dioClient, this._syncQueueRepository);

  /// Start syncing queue items
  Future<void> startSync() async {
    if (_isSyncing) {
      AppLogger.debug('Sync already in progress');
      return;
    }

    if (!ConnectivityService.isConnected) {
      AppLogger.debug('No network connection, skipping sync');
      return;
    }

    _isSyncing = true;
    AppLogger.info('Starting sync process');

    try {
      final pendingItems = await _syncQueueRepository.getPendingItems();

      for (final item in pendingItems) {
        // item is SyncQueueData (generated by build_runner)
        if (!ConnectivityService.isConnected) {
          AppLogger.warning('Network lost during sync');
          break;
        }

        try {
          await _syncItem(item);
          await _syncQueueRepository.removeFromQueue(item.id);
          AppLogger.debug('Successfully synced item: ${item.id}');
        } catch (e) {
          await _handleSyncError(item, e);
        }
      }
    } finally {
      _isSyncing = false;
      AppLogger.info('Sync process completed');
    }
  }

  /// Sync a single item
  Future<void> _syncItem(SyncQueueData item) async {
    final dio = _dioClient.instance;
    final payload = jsonDecode(item.payload) as Map<String, dynamic>;

    Response response;

    switch (item.method.toUpperCase()) {
      case 'GET':
        response = await dio.get(item.endpoint, queryParameters: payload);
        break;
      case 'POST':
        response = await dio.post(item.endpoint, data: payload);
        break;
      case 'PUT':
        response = await dio.put(item.endpoint, data: payload);
        break;
      case 'DELETE':
        response = await dio.delete(item.endpoint, data: payload);
        break;
      default:
        throw Exception('Unsupported HTTP method: ${item.method}');
    }

    if (response.statusCode != null && response.statusCode! >= 200 && response.statusCode! < 300) {
      AppLogger.debug('Item synced successfully: ${item.id}');
    } else {
      throw Exception('Sync failed with status: ${response.statusCode}');
    }
  }

  /// Handle sync error with exponential backoff
  Future<void> _handleSyncError(SyncQueueData item, dynamic error) async {
    final maxRetries = 5;
    final currentRetryCount = item.retryCount;

    if (currentRetryCount >= maxRetries) {
      AppLogger.error('Max retries reached for item: ${item.id}');
      await _syncQueueRepository.updateLastError(
        item.id,
        error.toString(),
      );
      // Optionally remove from queue or mark as failed
      return;
    }

    await _syncQueueRepository.incrementRetryCount(item.id);
    await _syncQueueRepository.updateLastError(item.id, error.toString());

    // Exponential backoff: 2^retryCount seconds
    final delaySeconds = pow(2, currentRetryCount).toInt();
    AppLogger.warning(
      'Sync failed for item ${item.id}, will retry in ${delaySeconds}s (attempt ${currentRetryCount + 1}/$maxRetries)',
    );
  }

  /// Check if sync is in progress
  bool get isSyncing => _isSyncing;

  /// Force sync (used when network comes back)
  Future<void> forceSync() async {
    if (ConnectivityService.isConnected) {
      await startSync();
    }
  }
}

