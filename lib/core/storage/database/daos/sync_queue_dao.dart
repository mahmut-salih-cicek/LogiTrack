import 'package:drift/drift.dart';
import '../app_database.dart';
import '../tables/sync_queue_table.dart';

part 'sync_queue_dao.g.dart';

@DriftAccessor(tables: [SyncQueue])
class SyncQueueDao extends DatabaseAccessor<AppDatabase> with _$SyncQueueDaoMixin {
  SyncQueueDao(super.db);

  // Note: SyncQueueData will be generated by build_runner
  Future<List<SyncQueueData>> getAllItems() => select(syncQueue).get();

  Future<List<SyncQueueData>> getPendingItems() =>
      (select(syncQueue)..orderBy([(item) => OrderingTerm.asc(item.createdAt)])).get();

  Future<SyncQueueData?> getItemById(String id) =>
      (select(syncQueue)..where((item) => item.id.equals(id))).getSingleOrNull();

  // ignore: undefined_identifier
  Future<void> insertItem(SyncQueueCompanion item) =>
      into(syncQueue).insert(item, mode: InsertMode.replace);

  Future<void> incrementRetryCount(String id) async {
    final item = await getItemById(id);
    if (item != null) {
      // ignore: undefined_identifier
      (update(syncQueue)..where((i) => i.id.equals(id))).write(
        SyncQueueCompanion(
          retryCount: Value(item.retryCount + 1),
          lastRetryAt: Value(DateTime.now()),
        ),
      );
    }
  }

  Future<void> updateLastError(String id, String error) =>
      // ignore: undefined_identifier
      (update(syncQueue)..where((i) => i.id.equals(id))).write(SyncQueueCompanion(lastError: Value(error)));

  Future<void> deleteItem(String id) => (delete(syncQueue)..where((i) => i.id.equals(id))).go();

  Future<void> deleteAllItems() => delete(syncQueue).go();
}

