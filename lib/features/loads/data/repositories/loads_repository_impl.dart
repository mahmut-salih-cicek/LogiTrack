import 'dart:convert';
import 'package:drift/drift.dart';
import '../../domain/entities/load.dart';
import '../../domain/entities/stop.dart' as domain;
import '../../domain/repositories/loads_repository.dart';
import '../../../../core/utils/result.dart';
import '../../../../core/error/failures.dart';
import '../../../../core/error/app_exception.dart';
import '../../../../core/storage/database/app_database.dart' as db;
import '../../../../core/storage/database/tables/loads_table.dart';
import '../../../../core/storage/database/tables/stops_table.dart';
import '../datasources/loads_remote_datasource.dart';
import '../models/load_dto.dart';
import '../models/stop_dto.dart';

class LoadsRepositoryImpl implements LoadsRepository {
  final LoadsRemoteDataSource _remoteDataSource;
  final db.AppDatabase _database;

  LoadsRepositoryImpl(this._remoteDataSource, this._database);

  @override
  Future<Result<List<Load>>> getLoads({String? date, String? status}) async {
    try {
      // Try to get from remote first
      final remoteData = await _remoteDataSource.getLoads(date: date, status: status);
      
      // Convert to entities
      final loads = remoteData.map((json) {
        final dto = LoadDto.fromJson(json);
        return dto.toEntity();
      }).toList();

      // Save to local database
      await _saveLoadsToDatabase(loads);

      return Success(loads);
    } on AppException catch (e) {
      // If network fails, try to get from local database
      try {
        final localLoads = await _getLoadsFromDatabase(status: status);
        return Success(localLoads);
      } catch (dbError) {
        return FailureResult(NetworkFailure(e.message));
      }
    } catch (e) {
      return FailureResult(UnknownFailure('Failed to fetch loads: ${e.toString()}'));
    }
  }

  @override
  Future<Result<Load>> getLoadDetail(String loadId) async {
    try {
      final remoteData = await _remoteDataSource.getLoadDetail(loadId);
      final dto = LoadDto.fromJson(remoteData);
      final load = dto.toEntity();

      // Save to local database
      await _saveLoadToDatabase(load);

      return Success(load);
    } on AppException catch (e) {
      // Try local database
      try {
        final localLoad = await _getLoadFromDatabase(loadId);
        if (localLoad != null) {
          return Success(localLoad);
        }
        return FailureResult(NetworkFailure(e.message));
      } catch (dbError) {
        return FailureResult(NetworkFailure(e.message));
      }
    } catch (e) {
      return FailureResult(UnknownFailure('Failed to fetch load detail: ${e.toString()}'));
    }
  }

  @override
  Future<Result<void>> assignLoadToDriver(String loadId, String driverId) async {
    try {
      await _remoteDataSource.assignLoadToDriver(loadId, driverId);
      
      // Update local database
      await _database.loadsDao.updateLoadStatus(loadId, 'assigned');

      return const Success(null);
    } on AppException catch (e) {
      return FailureResult(NetworkFailure(e.message));
    } catch (e) {
      return FailureResult(UnknownFailure('Failed to assign load: ${e.toString()}'));
    }
  }

  Future<void> _saveLoadsToDatabase(List<Load> loads) async {
    for (final load in loads) {
      await _saveLoadToDatabase(load);
    }
  }

  Future<void> _saveLoadToDatabase(Load load) async {
    // Save load
    // Note: LoadsCompanion will be generated by build_runner
    await _database.loadsDao.insertLoad(
      db.LoadsCompanion.insert(
        id: load.id,
        loadNumber: load.loadNumber,
        status: load.status,
        assignedDriverId: Value(load.assignedDriverId),
        assignedDriverName: Value(load.assignedDriverName),
        pickupAddress: load.pickupAddress,
        deliveryAddress: load.deliveryAddress,
        pickupDate: load.pickupDate,
        deliveryDate: load.deliveryDate,
        createdAt: load.createdAt,
        rawData: jsonEncode({
          'id': load.id,
          'loadNumber': load.loadNumber,
          'status': load.status,
        }),
      ),
    );

    // Save stops
    // Note: StopsCompanion will be generated by build_runner
    for (final stop in load.stops) {
      await _database.stopsDao.insertStop(
        db.StopsCompanion.insert(
          id: stop.id,
          loadId: stop.loadId,
          type: stop.type,
          address: stop.address,
          latitude: stop.latitude,
          longitude: stop.longitude,
          geofenceRadius: stop.geofenceRadius,
          status: stop.status,
          expectedArrival: Value(stop.expectedArrival),
          actualArrival: Value(stop.actualArrival),
          actualDeparture: Value(stop.actualDeparture),
          rawData: jsonEncode({
            'id': stop.id,
            'type': stop.type,
            'status': stop.status,
          }),
        ),
      );
    }
  }

  Future<List<Load>> _getLoadsFromDatabase({String? status}) async {
    final loadsData = status != null
        ? await _database.loadsDao.getLoadsByStatus(status)
        : await _database.loadsDao.getAllLoads();

    final loads = <Load>[];
    for (final loadData in loadsData) {
      final stopsData = await _database.stopsDao.getStopsByLoadId(loadData.id);
      // Convert from database to entity (simplified)
      // In production, you'd have proper mappers
      loads.add(Load(
        id: loadData.id,
        loadNumber: loadData.loadNumber,
        status: loadData.status,
        assignedDriverId: loadData.assignedDriverId,
        assignedDriverName: loadData.assignedDriverName,
        pickupAddress: loadData.pickupAddress,
        deliveryAddress: loadData.deliveryAddress,
        pickupDate: loadData.pickupDate,
        deliveryDate: loadData.deliveryDate,
        createdAt: loadData.createdAt,
        stops: stopsData.map((s) => domain.Stop(
          id: s.id,
          loadId: s.loadId,
          type: s.type,
          address: s.address,
          latitude: s.latitude,
          longitude: s.longitude,
          geofenceRadius: s.geofenceRadius,
          status: s.status,
          expectedArrival: s.expectedArrival,
          actualArrival: s.actualArrival,
          actualDeparture: s.actualDeparture,
        )).toList(),
      ));
    }

    return loads;
  }

  Future<Load?> _getLoadFromDatabase(String loadId) async {
    final loadData = await _database.loadsDao.getLoadById(loadId);
    if (loadData == null) return null;

    final stopsData = await _database.stopsDao.getStopsByLoadId(loadId);
    
    return Load(
      id: loadData.id,
      loadNumber: loadData.loadNumber,
      status: loadData.status,
      assignedDriverId: loadData.assignedDriverId,
      assignedDriverName: loadData.assignedDriverName,
      pickupAddress: loadData.pickupAddress,
      deliveryAddress: loadData.deliveryAddress,
      pickupDate: loadData.pickupDate,
      deliveryDate: loadData.deliveryDate,
      createdAt: loadData.createdAt,
      stops: stopsData.map((s) => domain.Stop(
        id: s.id,
        loadId: s.loadId,
        type: s.type,
        address: s.address,
        latitude: s.latitude,
        longitude: s.longitude,
        geofenceRadius: s.geofenceRadius,
        status: s.status,
        expectedArrival: s.expectedArrival,
        actualArrival: s.actualArrival,
        actualDeparture: s.actualDeparture,
      )).toList(),
    );
  }
}

